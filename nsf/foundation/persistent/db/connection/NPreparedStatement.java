package nsf.foundation.persistent.db.connection;
/**
 * @(#) NPreparedStatement.java
 */
import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;

import nsf.support.tools.time.NStopWatch;

/**
 * <pre>
 * NPreparedStatement는 NConnection을 통하여 PreparedStatement를 생성할 경우에 리턴된다.
 * NPreparedStatement는 PreparedStatement에 설정되는 parameter정보를 내부적으로 저장하고,
 * 사용자에 의해서 execute(), executeUpdate(), executeQuery()가 수행될때, 관련 DB작업에 대한 로그정보를
 * 남겨줄수 있도록 NDBTrace 클래스를 통하여 적절한 메소드를 호출해주는 역할을 한다. 
 * </pre>
 * @since 2007/01/05
 * @version NSF 1.0
 * @author Nova China 량명호<br>
 */
public class NPreparedStatement implements PreparedStatement {
	private PreparedStatement statement;
	private String sql = null;
	private ArrayList params = new ArrayList();
	private void saveParam(int idx, Object arg) {
		if (idx < 1)
			return;
		while (idx > params.size()) {
			params.add(null);
		}
		params.set(idx - 1, arg);
	}

	/**
	 * NPreparedStatement 생성자
	 * 
	 */
	public NPreparedStatement(PreparedStatement statement, String sql) {
		this.statement = statement;
		this.sql = sql;
	}
	/**
	 * Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
	 * @return a ResultSet object
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#executeQuery()
	 */
	public ResultSet executeQuery() throws SQLException {
		NStopWatch watch = new NStopWatch();
		boolean isError = false;
		try {
			return statement.executeQuery(); //new _ResultSet(statement.executeQuery());
		} catch (SQLException se) {
			isError = true;
			//NDBTracer.print_error("PSTMT.EQ", watch.getElapsed(), sql, null, se.toString());
			NDBTracer.print_error("PSTMT.EQ", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				NDBTracer.print_sql("PSTMT.EQ", watch.getElapsed(), sql, params, 0);
		}
	}
	/**
	 * Executes the SQL statement in this PreparedStatement object, which must be an SQL INSERT, 
	 * UPDATE or DELETE statement; or an SQL statement that returns nothing, such as a DDL statement
	 * @return either (1) the row count for INSERT, UPDATE, or DELETE statements or (2) 0 for SQL statements that return nothing 
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#executeUpdate()
	 */
	public int executeUpdate() throws SQLException {
		NStopWatch watch = new NStopWatch();
		int result = 0;
		boolean isError = false;
		try {
			result = statement.executeUpdate();
		} catch (SQLException se) {
			isError = true;
			//NDBTracer.print_error("PSTMT.EU", watch.getElapsed(), sql, null, se.toString());
			NDBTracer.print_error("PSTMT.EU", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				NDBTracer.print_sql("PSTMT.EU", watch.getElapsed(), sql, params, result);
		}
		return result;
	}
	/**
	 * Sets the designated parameter to SQL NULL
	 * @param parameterIndex
	 * @param SQL type code
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setNull(int, int)
	 */
	public void setNull(int parameterIndex, int sqlType) throws SQLException {
		saveParam(parameterIndex, null);
		statement.setNull(parameterIndex, sqlType);
	}
	/**
	 * Sets the designated parameter to the given Java boolean value. 
	 * The driver converts this to an SQL BIT value when it sends it to the database
	 * @param parameterIndex
	 * @param the parameter value
	 * @throws SQLException 
	 * @see java.sql.PreparedStatement#setBoolean(int, boolean)
	 */
	public void setBoolean(int parameterIndex, boolean x) throws SQLException {
		saveParam(parameterIndex, new Boolean(x));
		statement.setBoolean(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given Java byte value. 
	 * The driver converts this to an SQL TINYINT value when it sends it to the database
	 * @param parameterIndex
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setByte(int, byte)
	 */
	public void setByte(int parameterIndex, byte x) throws SQLException {
		saveParam(parameterIndex, new Byte(x));
		statement.setByte(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given Java short value
	 * @param parameter Index
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setShort(int, short)
	 */
	public void setShort(int parameterIndex, short x) throws SQLException {
		saveParam(parameterIndex, new Short(x));
		statement.setShort(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given Java int value
	 * @param parameter Index
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setInt(int, int)
	 */
	public void setInt(int parameterIndex, int x) throws SQLException {
		saveParam(parameterIndex, new Integer(x));
		statement.setInt(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given Java long value
	 * @param parameter Index
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setLong(int, long)
	 */
	public void setLong(int parameterIndex, long x) throws SQLException {
		saveParam(parameterIndex, new Long(x));
		statement.setLong(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given Java float value
	 * @param parameter Index
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setFloat(int, float)
	 */
	public void setFloat(int parameterIndex, float x) throws SQLException {
		saveParam(parameterIndex, new Float(x));
		statement.setFloat(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given Java double value
	 * @param parameter Index
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setDouble(int, double)
	 */
	public void setDouble(int parameterIndex, double x) throws SQLException {
		saveParam(parameterIndex, new Double(x));
		statement.setDouble(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given java.math.BigDecimal value
	 * @param parameter Index
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setBigDecimal(int, BigDecimal)
	 */
	public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
		saveParam(parameterIndex, x);
		statement.setBigDecimal(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given Java String value
	 * @param parameter Index
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setString(int, String)
	 */
	public void setString(int parameterIndex, String x) throws SQLException {
		saveParam(parameterIndex, x);
		statement.setString(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given Java array of bytes
	 * @param parameter Index
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setBytes(int, byte[])
	 */
	public void setBytes(int parameterIndex, byte[] x) throws SQLException {
		saveParam(parameterIndex, "" + x);
		statement.setBytes(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given java.sql.Date value
	 * @param parameter Index
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setDate(int, Date)
	 */
	public void setDate(int parameterIndex, Date x) throws SQLException {
		saveParam(parameterIndex, x);
		statement.setDate(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given java.sql.Time value
	 * @param parameter Index
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setTime(int, Time)
	 */
	public void setTime(int parameterIndex, Time x) throws SQLException {
		saveParam(parameterIndex, x);
		statement.setTime(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given java.sql.Timestamp value
	 * @param parameter Index
	 * @param parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setTimestamp(int, Timestamp)
	 */
	public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException {
		saveParam(parameterIndex, x);
		statement.setTimestamp(parameterIndex, x);
	}
	/**
	 * Sets the designated parameter to the given input stream
	 * @param parameter Index
	 * @param parameter value
	 * @param the number of bytes in the stream
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setAsciiStream(int, InputStream, int)
	 */
	public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {
		saveParam(parameterIndex, "" + x + "(" + length + ")");
		statement.setAsciiStream(parameterIndex, x, length);
	}
	/**
	 * Sets the designated parameter to the given input stream
	 * @param parameter Index
	 * @param parameter value
	 * @param the number of bytes in the stream
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setUnicodeStream(int, InputStream, int)
	 * @deprecated
	 */
	public void setUnicodeStream(int parameterIndex, InputStream x, int length)
		throws SQLException {
		throw new SQLException("Not Support : setUnicodeStream(int parameterIndex, InputStream x, int length)");
	}
	/**
	 * Sets the designated parameter to the given input stream
	 * @param parameter Index
	 * @param parameter value
	 * @param the number of bytes in the stream
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setBinaryStream(int, InputStream, int)
	 */
	public void setBinaryStream(int parameterIndex, InputStream x, int length)
		throws SQLException {
		saveParam(parameterIndex, "InputStream(" + length + ")");
		statement.setBinaryStream(parameterIndex, x, length);
	}
	/**
	 * Clears the current parameter values immediately
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#clearParameters()
	 */
	public void clearParameters() throws SQLException {
		params = new ArrayList();
		statement.clearParameters();
	}
	/**
	 * Sets the value of the designated parameter with the given object
	 * @param parameter Index
	 * @param the object containing the input parameter value
	 * @param the SQL type
	 * @param this is the number of digits after the decimal point
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setObject(int, Object, int, int)
	 */
	public void setObject(int parameterIndex, Object x, int targetSqlType, int scale)
		throws SQLException {
		saveParam(parameterIndex, x);
		statement.setObject(parameterIndex, x, targetSqlType, scale);
	}
	/**
	 * Sets the value of the designated parameter with the given object
	 * @param parameter Index
	 * @param the object containing the input parameter value
	 * @param the SQL type
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setObject(int, Object, int)
	 */
	public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
		saveParam(parameterIndex, x);
		statement.setObject(parameterIndex, x, targetSqlType);
	}
	
	/**
	 * Sets the value of the designated parameter using the given object
	 * @param parameter Index
	 * @param the object containing the input parameter value
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setObject(int, Object)
	 */
	public void setObject(int parameterIndex, Object x) throws SQLException {
		saveParam(parameterIndex, x);
		statement.setObject(parameterIndex, x);
	}
	
	/**
	 * Executes the SQL statement in this PreparedStatement object
	 * @return e if the first result is a ResultSet object
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#execute()
	 */
	public boolean execute() throws SQLException {
		NStopWatch watch = new NStopWatch();
		boolean isError = false;
		try {
			return statement.execute();
		} catch (SQLException se) {
			isError = true;
			NDBTracer.print_error("PSTMT.E", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				//NDBTracer.print_sql("PSTMT.E", watch.getElapsed(), sql, null, 0);
				NDBTracer.print_sql("PSTMT.E", watch.getElapsed(), sql, params, 0);
		}
	}
	/**
	 * Adds a set of parameters to this PreparedStatement object's batch of commands
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#addBatch()
	 */
	public void addBatch() throws SQLException {
		statement.addBatch();
	}
	/**
	 * Sets the designated parameter to the given Reader object
	 * @param parameter Index
	 * @param the java.io.Reader object that contains the Unicode data
	 * @param the number of characters in the stream 
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setCharacterStream(int, Reader, int)
	 */
	public void setCharacterStream(int parameterIndex, Reader reader, int length)
		throws SQLException {
		saveParam(parameterIndex, "" + reader);
		statement.setCharacterStream(parameterIndex, reader, length);
	}
	/**
	 * Sets the designated parameter to the given REF(<structured-type>) value
	 * @param parameter Index
	 * @param an SQL REF value 
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setRef(int, Ref)
	 */
	public void setRef(int i, Ref x) throws SQLException {
		statement.setRef(i, x);
	}
	/**
	 * Sets the designated parameter to the given Blob object
	 * @param parameter Index
	 * @param a Blob object that maps an SQL BLOB value 
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setBlob(int, Blob)
	 */
	public void setBlob(int i, Blob x) throws SQLException {
		saveParam(i, "" + x);
		statement.setBlob(i, x);
	}
	/**
	 * Sets the designated parameter to the given Clob object
	 * @param parameter Index
	 * @param a Clob object that maps an SQL CLOB value 
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setClob(int, Clob)
	 */
	public void setClob(int i, Clob x) throws SQLException {
		saveParam(i, "" + x);
		statement.setClob(i, x);
	}
	/**
	 * Sets the designated parameter to the given Array object
	 * @param parameter Index
	 * @param an Array object that maps an SQL ARRAY value 
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setArray(int, Array)
	 */
	public void setArray(int i, java.sql.Array x) throws SQLException {
		saveParam(i, "" + x);
		statement.setArray(i, x);
	}
	/**
	 * Retrieves a ResultSetMetaData object 
	 * @return ResultSetMetaData object 
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#getMetaData()
	 */
	public ResultSetMetaData getMetaData() throws SQLException {
		return statement.getMetaData();
	}
	/**
	 * Sets the designated parameter to the given java.sql.Date value
	 * @param parameterIndex
	 * @param parameter value
	 * @param the Calendar object
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setDate(int, Date, Calendar)
	 */
	public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException {
		saveParam(parameterIndex, "" + x);
		statement.setDate(parameterIndex, x, cal);
	}
	/**
	 * Sets the designated parameter to the given java.sql.Time value
	 * @param parameterIndex
	 * @param parameter value
	 * @param the Calendar object
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setTime(int, Time, Calendar)
	 */
	public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException {
		saveParam(parameterIndex, "" + x);
		statement.setTime(parameterIndex, x, cal);
	}
	/**
	 * Sets the designated parameter to the given java.sql.Timestamp value
	 * @param parameterIndex
	 * @param parameter value
	 * @param the Calendar object
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setTimestamp(int, Timestamp, Calendar)
	 */
	public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {
		saveParam(parameterIndex, "" + x);
		statement.setTimestamp(parameterIndex, x, cal);
	}
	/**
	 * Sets the designated parameter to SQL NULL
	 * @param parameterIndex
	 * @param sqlType
	 * @param type Name
	 * @throws SQLException
	 * @see java.sql.PreparedStatement#setNull(int, int, String)
	 */
	public void setNull(int paramIndex, int sqlType, String typeName) throws SQLException {
		saveParam(paramIndex, null);
		statement.setNull(paramIndex, sqlType, typeName);
	}
	/**
	 * Executes the SQL query
	 * @param sql
	 * @throws SQLException
	 * @see java.sql.Statement#executeQuery(String)
	 */
	public ResultSet executeQuery(String sql) throws SQLException {
		NStopWatch watch = new NStopWatch();
		boolean isError = false;
		try {
			return statement.executeQuery(sql); //new _ResultSet(statement.executeQuery(sql));
		} catch (SQLException se) {
			isError = true;
			//NDBTracer.print_error("PSTMT.EQ", watch.getElapsed(), sql, null, se.toString());
			NDBTracer.print_error("PSTMT.EQ", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				//NDBTracer.print_sql("PSTMT.EQ", watch.getElapsed(), sql, null, 0);
			    NDBTracer.print_sql("PSTMT.EQ", watch.getElapsed(), sql, params, 0);
		}
	}
	/**
	 * Executes the SQL statement
	 * @param sql
	 * @return int
	 * @throws SQLException
	 * @see java.sql.Statement#executeUpdate(String)
	 */
	public int executeUpdate(String sql) throws SQLException {
		NStopWatch watch = new NStopWatch();
		int result = 0;
		boolean isError = false;
		try {
			result = statement.executeUpdate(sql);
		} catch (SQLException se) {
			isError = true;
			//NDBTracer.print_error("PSTMT.EU", watch.getElapsed(), sql, null, se.toString());
			NDBTracer.print_error("PSTMT.EU", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				NDBTracer.print_sql("PSTMT.EU", watch.getElapsed(), sql, null, result);
			    NDBTracer.print_sql("PSTMT.EU", watch.getElapsed(), sql, params, result);
		}
		return result;
	}
	/**
	 * Releases this Statement object's database and JDBC resources immediately 
	 * @throws SQLException
	 * @see java.sql.Statement#close()
	 */
	public void close() throws SQLException {
		try {
			statement.close();
		} catch (SQLException e) {
			//XLog.print(false, "pstmt close error => " + e);
			throw e;
		}
	}
	/**
	 * Retrieves the maximum number of bytes 
	 * @return the current column size limit
	 * @throws SQLException
	 * @see java.sql.Statement#getMaxFieldSize()
	 */
	public int getMaxFieldSize() throws SQLException {
		return statement.getMaxFieldSize();
	}
	/**
	 * Sets the limit for the maximum number of bytes
	 * @param the new column size limit 
	 * @throws SQLException
	 * @see java.sql.Statement#setMaxFieldSize(int)
	 */
	public void setMaxFieldSize(int max) throws SQLException {
		statement.setMaxFieldSize(max);
	}
	/**
	 * Retrieves the maximum number of rows
	 * @return the current maximum number 
	 * @throws SQLException
	 * @see java.sql.Statement#getMaxRows()
	 */
	public int getMaxRows() throws SQLException {
		return statement.getMaxRows();
	}
	/**
	 * Sets the limit for the maximum number 
	 * @param the new max rows limit
	 * @throws SQLException
	 * @see java.sql.Statement#setMaxRows(int)
	 */
	public void setMaxRows(int max) throws SQLException {
		statement.setMaxRows(max);
	}
	/**
	 * Sets escape processing on or off
	 * @param true to enable escape processing
	 * @throws SQLException
	 * @see java.sql.Statement#setEscapeProcessing(boolean)
	 */
	public void setEscapeProcessing(boolean enable) throws SQLException {
		statement.setEscapeProcessing(enable);
	}
	/**
	 * Retrieves the number of seconds the driver will wait for a Statement object to execute
	 * @return the current query timeout limit in seconds
	 * @throws SQLException
	 * @see java.sql.Statement#getQueryTimeout()
	 */
	public int getQueryTimeout() throws SQLException {
		return statement.getQueryTimeout();
	}
	/**
	 * Sets the number of seconds the driver will wait for a Statement object to execute to the given number of seconds
	 * @param the new query timeout limit in seconds
	 * @throws SQLException
	 * @see java.sql.Statement#setQueryTimeout(int)
	 */
	public void setQueryTimeout(int seconds) throws SQLException {
		statement.setQueryTimeout(seconds);
	}
	/**
	 * Cancels this Statement object if both the DBMS and driver support aborting an SQL statement
	 * @throws SQLException
	 * @see java.sql.Statement#cancel()
	 */
	public void cancel() throws SQLException {
		statement.cancel();
	}
	/**
	 * Retrieves the first warning reported by calls on this Statement object
	 * @return the first SQLWarning object or null
	 * @throws SQLException
	 * @see java.sql.Statement#getWarnings()
	 */
	public SQLWarning getWarnings() throws SQLException {
		return statement.getWarnings();
	}
	/**
	 * Clears all the warnings reported on this Statement object
	 * @throws SQLException
	 * @see java.sql.Statement#clearWarnings()
	 */
	public void clearWarnings() throws SQLException {
		statement.clearWarnings();
	}
	/**
	 * Sets the SQL cursor name to the given String
	 * @param the new cursor name
	 * @throws SQLException
	 * @see java.sql.Statement#setCursorName(String)
	 */
	public void setCursorName(String name) throws SQLException {
		statement.setCursorName(name);
	}
	/**
	 * Executes the given SQL statement
	 * @param SQL statement 
	 * @throws SQLException
	 * @see java.sql.Statement#execute(String)
	 */
	public boolean execute(String sql) throws SQLException {
		NStopWatch watch = new NStopWatch();
		boolean isError = false;
		try {
			return statement.execute(sql);
		} catch (SQLException se) {
			isError = true;
			NDBTracer.print_error("PSTMT.E", watch.getElapsed(), sql, null, se.toString());
			throw se;
		} finally {
			if (!isError)
				NDBTracer.print_sql("PSTMT.E", watch.getElapsed(), sql, null, 0);
		}
	}
	/**
	 * Retrieves the current result as a ResultSet object
	 * @return the current result as a ResultSet object
	 * @throws SQLException
	 * @see java.sql.Statement#getResultSet()
	 */
	public ResultSet getResultSet() throws SQLException {
		return statement.getResultSet();
	}
	/**
	 * Retrieves the current result as an update count
	 * @return the current result as an update count
	 * @throws SQLException
	 * @see java.sql.Statement#getUpdateCount()
	 */
	public int getUpdateCount() throws SQLException {
		return statement.getUpdateCount();
	}
	/**
	 * Moves to this Statement object's next result
	 * @return true if the next result is a ResultSet object
	 * @throws SQLException
	 * @see java.sql.Statement#getMoreResults()
	 */
	public boolean getMoreResults() throws SQLException {
		return statement.getMoreResults();
	}
	/**
	 * Gives the driver a hint as to the direction
	 * @param the initial direction for processing rows 
	 * @throws SQLException
	 * @see java.sql.Statement#setFetchDirection(int)
	 */
	public void setFetchDirection(int direction) throws SQLException {
		statement.setFetchDirection(direction);
	}
	/**
	 * Retrieves the direction for fetching rows from database tables 
	 * @return the default fetch direction
	 * @throws SQLException 
	 * @see java.sql.Statement#getFetchDirection()
	 */
	public int getFetchDirection() throws SQLException {
		return statement.getFetchDirection();
	}
	/**
	 * Gives the JDBC driver a hint as to the number of rows 
	 * @param the number of rows to fetch
	 * @throws SQLException 
	 * @see java.sql.Statement#setFetchSize(int)
	 */
	public void setFetchSize(int rows) throws SQLException {
		statement.setFetchSize(rows);
	}
	/**
	 * Retrieves the number of result set rows
	 * @return the default fetch size for result sets
	 * @throws SQLException 
	 * @see java.sql.Statement#getFetchSize()
	 */
	public int getFetchSize() throws SQLException {
		return statement.getFetchSize();
	}
	/**
	 * Retrieves the result set concurrency for ResultSet objects 
	 * @return either ResultSet.CONCUR_READ_ONLY or ResultSet.CONCUR_UPDATABLE
	 * @throws SQLException 
	 * @see java.sql.Statement#getResultSetConcurrency()
	 */
	public int getResultSetConcurrency() throws SQLException {
		return statement.getResultSetConcurrency();
	}
	/**
	 * Retrieves the result set type for ResultSet objects 
	 * @return int
	 * @throws SQLException
	 * @see java.sql.Statement#getResultSetType()
	 */
	public int getResultSetType() throws SQLException {
		return statement.getResultSetType();
	}
	/**
	 * Adds the given SQL command to the current list of commmands for this Statement object
	 * @param a static SQL INSERT or UPDATE statement
	 * @throws SQLException 
	 * @see java.sql.Statement#addBatch(String)
	 */
	public void addBatch(String sql) throws SQLException {
		NDBTracer.print_sql("PSTMT.AB", sql, null);
		statement.addBatch(sql);
	}
	/**
	 * Empties this Statement object's current list of SQL commands
	 * @throws SQLException
	 * @see java.sql.Statement#clearBatch()
	 */
	public void clearBatch() throws SQLException {
		statement.clearBatch();
	}
	/**
	 * Submits a batch of commands to the database for execution 
	 * @return an array of update counts 
	 * @throws SQLException
	 * @see java.sql.Statement#executeBatch()
	 */
	public int[] executeBatch() throws SQLException {
		NStopWatch watch = new NStopWatch();
		boolean isError = false;
		try {
			return statement.executeBatch();
		} catch (SQLException se) {
			isError = true;
			//NDBTracer.print_error("PSTMT.EB", watch.getElapsed(), sql, null, se.toString());
			NDBTracer.print_error("PSTMT.EB", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				//NDBTracer.print_sql("PSTMT.EB", watch.getElapsed(), sql, null, 0);
				NDBTracer.print_sql("PSTMT.EB", watch.getElapsed(), sql, params, 0);
		}
	}
	/**
	 * Retrieves the Connection object
	 * @return the connection 
	 * @throws SQLException
	 * @see java.sql.Statement#getConnection()
	 */
	public Connection getConnection() throws SQLException {
		return new NConnection(this.statement.getConnection());
	}
	/**
	 * Retrieves the number, types and properties of this PreparedStatement object's parameters
	 * @return a ParameterMetaData object 
	 * @throws SQLException
	 * @see java.sql.Statement#getParameterMetaData()
	 */
	public ParameterMetaData getParameterMetaData() throws SQLException {
		return statement.getParameterMetaData();
	}
	/**
	 * Sets the designated parameter to the given java.net.URL value
	 * @param parameter Index
	 * @param the java.net.URL object 
	 * @throws SQLException
	 * @see java.sql.Statement#setURL(int, URL)
	 */
	public void setURL(int parameterIndex, URL x) throws SQLException {
		statement.setURL(parameterIndex, x);
	}
	/**
	 * NPreparedStatement를 통해서 execute가 호출된 경우 수행을 대행하고, 관련 로그를 남겨주는 메소드를
	 * 호출한다.
	 * @throws SQLException
	 */
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		NStopWatch watch = new NStopWatch();
		boolean isError = false;
		try {
			return statement.execute(sql, autoGeneratedKeys);
		} catch (SQLException se) {
			isError = true;
			//NDBTracer.print_error("PSTMT.E", watch.getElapsed(), sql, null, se.toString());
			NDBTracer.print_error("PSTMT.E", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				//NDBTracer.print_sql("PSTMT.E", watch.getElapsed(), sql, null, 0);
				NDBTracer.print_sql("PSTMT.E", watch.getElapsed(), sql, params, 0);
		}
	}
	/**
	 * NPreparedStatement를 통해서 execute가 호출된 경우 수행을 대행하고, 관련 로그를 남겨주는 메소드를
	 * 호출한다.
	 * @throws SQLException
	 */
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		NStopWatch watch = new NStopWatch();
		boolean isError = false;
		try {
			return statement.execute(sql, columnIndexes);
		} catch (SQLException se) {
			isError = true;
			//NDBTracer.print_error("PSTMT.E", watch.getElapsed(), sql, null, se.toString());
			NDBTracer.print_error("PSTMT.E", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				//NDBTracer.print_sql("PSTMT.E", watch.getElapsed(), sql, null, 0);
			    NDBTracer.print_sql("PSTMT.E", watch.getElapsed(), sql, params, 0);
		}
	}
	/**
	 * NPreparedStatement를 통해서 execute가 호출된 경우 수행을 대행하고, 관련 로그를 남겨주는 메소드를
	 * 호출한다.
	 * @throws SQLException
	 */
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		NStopWatch watch = new NStopWatch();
		boolean isError = false;
		try {
			return statement.execute(sql, columnNames);
		} catch (SQLException se) {
			isError = true;
			//NDBTracer.print_error("PSTMT.E", watch.getElapsed(), sql, null, se.toString());
			NDBTracer.print_error("PSTMT.E", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				//NDBTracer.print_sql("PSTMT.E", watch.getElapsed(), sql, null, 0);
				NDBTracer.print_sql("PSTMT.E", watch.getElapsed(), sql, params, 0);
		}
	}
	/**
	 * NPreparedStatement를 통해서 executeUpdate가 호출된 경우 수행을 대행하고, 관련 로그를 남겨주는 메소드를
	 * 호출한다.
	 * @throws SQLException
	 */
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		NStopWatch watch = new NStopWatch();
		int result = 0;
		boolean isError = false;
		try {
			result = statement.executeUpdate(sql, autoGeneratedKeys);
		} catch (SQLException se) {
			isError = true;
			//NDBTracer.print_error("PSTMT.EU", watch.getElapsed(), sql, null, se.toString());
			NDBTracer.print_error("PSTMT.EU", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				//NDBTracer.print_sql("PSTMT.EU", watch.getElapsed(), sql, null, result);
				NDBTracer.print_sql("PSTMT.EU", watch.getElapsed(), sql, params, result);
		}
		return result;
	}
	/**
	 * NPreparedStatement를 통해서 executeUpdate가 호출된 경우 수행을 대행하고, 관련 로그를 남겨주는 메소드를
	 * 호출한다.
	 * @throws SQLException
	 */
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		NStopWatch watch = new NStopWatch();
		int result = 0;
		boolean isError = false;
		try {
			result = statement.executeUpdate(sql, columnIndexes);
		} catch (SQLException se) {
			isError = true;
			//NDBTracer.print_error("PSTMT.EU", watch.getElapsed(), sql, null, se.toString());
			NDBTracer.print_error("PSTMT.EU", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				//NDBTracer.print_sql("PSTMT.EU", watch.getElapsed(), sql, null, result);
				NDBTracer.print_sql("PSTMT.EU", watch.getElapsed(), sql, params, result);
		}
		return result;
	}
	/**
	 * NPreparedStatement를 통해서 executeUpdate가 호출된 경우 수행을 대행하고, 관련 로그를 남겨주는 메소드를
	 * 호출한다.
	 * @throws SQLException
	 */
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		NStopWatch watch = new NStopWatch();
		int result = 0;
		boolean isError = false;
		try {
			result = statement.executeUpdate(sql, columnNames);
		} catch (SQLException se) {
			isError = true;
			//NDBTracer.print_error("PSTMT.EU", watch.getElapsed(), sql, null, se.toString());
			NDBTracer.print_error("PSTMT.EU", watch.getElapsed(), sql, params, se.toString());
			throw se;
		} finally {
			if (!isError)
				//NDBTracer.print_sql("PSTMT.EU", watch.getElapsed(), sql, null, result);
			    NDBTracer.print_sql("PSTMT.EU", watch.getElapsed(), sql, params, result);
		}
		return result;
	}
	/**
	 * Retrieves any auto-generated keys created as a result of executing this Statement object
	 * @return a ResultSet object 
	 * @throws SQLException
	 * @see java.sql.Statement#getGeneratedKeys()
	 */
	public ResultSet getGeneratedKeys() throws SQLException {
		return statement.getGeneratedKeys();
	}
	/**
	 * Moves to this Statement object's next result
	 * @param current 
	 * @return true if the next result is a ResultSet object
	 * @throws SQLException
	 * @see java.sql.Statement#getMoreResults(int)
	 */
	public boolean getMoreResults(int current) throws SQLException {
		return statement.getMoreResults(current);
	}
	/**
	 * Retrieves the result set holdability for ResultSet objects generated by this Statement object
	 * @return int
	 * @throws SQLException
	 * @see java.sql.Statement#getResultSetHoldability()
	 */
	public int getResultSetHoldability() throws SQLException {
		return statement.getResultSetHoldability();
	}
}

